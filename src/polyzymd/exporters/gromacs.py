"""
GROMACS export functionality for PolyzyMD.

This module provides comprehensive GROMACS export capabilities including:
- MDP file generation from PolyzyMD config parameters
- Position restraint file generation for equilibration
- Topology modification with #ifdef POSRES blocks
- Automated run script generation

The generated files are designed to match OpenFF Interchange force field
parameters (rcoulomb=0.9, rvdw=0.9, PME, etc.) for 1:1 parity with OpenMM.

Made by PolyzyMD, by Joseph R. Laforet Jr.
"""

from __future__ import annotations

import logging
import re
from dataclasses import dataclass, field
from datetime import datetime
from pathlib import Path
from typing import TYPE_CHECKING, Dict, List, Optional, Tuple, Union

if TYPE_CHECKING:
    from openff.interchange import Interchange
    from openmm.app import Topology as OpenMMTopology

    from polyzymd.config.schema import (
        EquilibrationStageConfig,
        SimulationConfig,
        SimulationPhaseConfig,
    )
    from polyzymd.core.atom_groups import AtomGroupResolver, SystemComponentInfo

logger = logging.getLogger(__name__)

# =============================================================================
# Constants and Mappings
# =============================================================================

# Thermostat mapping: PolyzyMD -> GROMACS
THERMOSTAT_MAP = {
    "LangevinMiddle": "v-rescale",
    "Langevin": "v-rescale",
    "NoseHoover": "nose-hoover",
    "Andersen": "andersen",
}

# Barostat mapping: PolyzyMD -> GROMACS (tcoupl, pcoupltype)
BAROSTAT_MAP = {
    "MC": ("c-rescale", "isotropic"),
    "MCA": ("c-rescale", "anisotropic"),
}

# OpenFF-compatible default parameters for 1:1 parity with OpenMM
OPENFF_DEFAULTS = {
    "cutoff-scheme": "verlet",
    "pbc": "xyz",
    "verlet-buffer-tolerance": 0.005,
    "coulombtype": "PME",
    "rcoulomb": 0.9,
    "fourier-spacing": 0.12,
    "ewald-rtol": 1e-5,
    "vdwtype": "cutoff",
    "rvdw": 0.9,
    "vdw-modifier": "Potential-switch",
    "rvdw-switch": 0.8,
    "DispCorr": "EnerPres",
    "constraints": "h-bonds",
    "constraint_algorithm": "lincs",
    "nstlist": 20,
}

# Water compressibility at 300K (bar^-1)
WATER_COMPRESSIBILITY = 4.5e-5

# Branding
POLYZYMD_BRANDING = "Made by PolyzyMD, by Joseph R. Laforet Jr."


# =============================================================================
# Data Classes
# =============================================================================


@dataclass
class MDPParameters:
    """Container for MDP file parameters.

    This dataclass holds all parameters needed to generate a GROMACS MDP file.
    Parameters are organized by category for clarity.
    """

    # Identification
    title: str = ""
    stage_type: str = ""  # em, eq, prod

    # Integration
    integrator: str = "md"
    dt: float = 0.002  # ps
    nsteps: int = 0

    # Output control
    nstxout: int = 0
    nstvout: int = 0
    nstlog: int = 5000
    nstenergy: int = 5000
    nstxout_compressed: int = 5000
    compressed_x_grps: str = "System"

    # Neighbor searching (OpenFF defaults)
    cutoff_scheme: str = "verlet"
    nstlist: int = 20
    pbc: str = "xyz"
    verlet_buffer_tolerance: float = 0.005

    # Electrostatics (OpenFF defaults)
    coulombtype: str = "PME"
    rcoulomb: float = 0.9
    fourier_spacing: float = 0.12
    ewald_rtol: float = 1e-5

    # Van der Waals (OpenFF defaults)
    vdwtype: str = "cutoff"
    rvdw: float = 0.9
    vdw_modifier: str = "Potential-switch"
    rvdw_switch: float = 0.8
    dispcorr: str = "EnerPres"

    # Constraints
    continuation: bool = False
    constraints: str = "h-bonds"
    constraint_algorithm: str = "lincs"

    # Temperature coupling
    tcoupl: str = "no"
    tc_grps: str = "System"
    tau_t: float = 0.5
    ref_t: float = 300.0

    # Pressure coupling
    pcoupl: str = "no"
    pcoupltype: str = "isotropic"
    tau_p: float = 5.0
    ref_p: float = 1.0
    compressibility: float = WATER_COMPRESSIBILITY

    # Velocity generation
    gen_vel: bool = False
    gen_temp: float = 300.0
    gen_seed: int = -1

    # Energy minimization specific
    emtol: float = 500.0
    emstep: float = 0.01

    # Annealing (for temperature ramping)
    annealing: str = "no"
    annealing_npoints: int = 0
    annealing_time: List[float] = field(default_factory=list)
    annealing_temp: List[float] = field(default_factory=list)

    # Position restraints
    define: str = ""  # e.g., "-DPOSRES_PROTEIN -DPOSRES_LIGAND"

    def to_mdp_string(self) -> str:
        """Convert parameters to MDP file format string.

        Returns:
            String containing the MDP file contents.
        """
        lines = []

        # Header comment
        lines.append(f"; {self.title}")
        lines.append(f"; Generated by PolyzyMD on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        lines.append(f"; {POLYZYMD_BRANDING}")
        lines.append("")

        if self.stage_type == "em":
            lines.extend(self._generate_em_section())
        else:
            lines.extend(self._generate_md_section())

        return "\n".join(lines)

    def _generate_em_section(self) -> List[str]:
        """Generate MDP content for energy minimization."""
        lines = []

        # Integration
        lines.append("; Run control")
        lines.append(f"integrator      = {self.integrator}")
        lines.append(f"emtol           = {self.emtol}")
        lines.append(f"emstep          = {self.emstep}")
        lines.append(f"nsteps          = {self.nsteps}")
        lines.append("")

        # Output
        lines.append("; Output control")
        lines.append("nstxout         = 0")
        lines.append(f"nstlog          = {self.nstlog}")
        lines.append(f"nstenergy       = {self.nstenergy}")
        lines.append("")

        # Neighbor searching
        lines.extend(self._generate_neighbor_section())

        # Electrostatics
        lines.extend(self._generate_electrostatics_section())

        # Van der Waals
        lines.extend(self._generate_vdw_section())

        # No temperature/pressure coupling
        lines.append("; No temperature/pressure coupling during minimization")
        lines.append("tcoupl          = no")
        lines.append("pcoupl          = no")

        return lines

    def _generate_md_section(self) -> List[str]:
        """Generate MDP content for MD simulations."""
        lines = []

        # Run control
        lines.append("; Run control")
        lines.append(f"integrator      = {self.integrator}")
        lines.append(f"dt              = {self.dt}")
        lines.append(f"nsteps          = {self.nsteps}")
        lines.append("")

        # Output control
        lines.append("; Output control")
        lines.append(f"nstxout         = {self.nstxout}")
        lines.append(f"nstvout         = {self.nstvout}")
        lines.append(f"nstlog          = {self.nstlog}")
        lines.append(f"nstenergy       = {self.nstenergy}")
        lines.append(f"nstxout-compressed = {self.nstxout_compressed}")
        if self.compressed_x_grps:
            lines.append(f"compressed-x-grps = {self.compressed_x_grps}")
        lines.append("")

        # Constraints
        lines.append("; Bond constraints")
        lines.append(f"continuation    = {'yes' if self.continuation else 'no'}")
        lines.append(f"constraints     = {self.constraints}")
        lines.append(f"constraint_algorithm = {self.constraint_algorithm}")
        lines.append("")

        # Neighbor searching
        lines.extend(self._generate_neighbor_section())

        # Electrostatics
        lines.extend(self._generate_electrostatics_section())

        # Van der Waals
        lines.extend(self._generate_vdw_section())

        # Temperature coupling
        lines.append("; Temperature coupling")
        lines.append(f"tcoupl          = {self.tcoupl}")
        lines.append(f"tc-grps         = {self.tc_grps}")
        lines.append(f"tau_t           = {self.tau_t}")
        lines.append(f"ref_t           = {self.ref_t}")
        lines.append("")

        # Annealing (if enabled)
        if self.annealing != "no" and self.annealing_npoints > 0:
            lines.append("; Temperature annealing")
            lines.append(f"annealing       = {self.annealing}")
            lines.append(f"annealing-npoints = {self.annealing_npoints}")
            lines.append(f"annealing-time  = {' '.join(str(t) for t in self.annealing_time)}")
            lines.append(f"annealing-temp  = {' '.join(str(t) for t in self.annealing_temp)}")
            lines.append("")

        # Pressure coupling
        lines.append("; Pressure coupling")
        if self.pcoupl != "no":
            lines.append(f"pcoupl          = {self.pcoupl}")
            lines.append(f"pcoupltype      = {self.pcoupltype}")
            lines.append(f"tau_p           = {self.tau_p}")
            lines.append(f"ref_p           = {self.ref_p}")
            lines.append(f"compressibility = {self.compressibility}")
        else:
            lines.append("pcoupl          = no")
        lines.append("")

        # Velocity generation
        lines.append("; Velocity generation")
        if self.gen_vel:
            lines.append("gen_vel         = yes")
            lines.append(f"gen_temp        = {self.gen_temp}")
            lines.append(f"gen_seed        = {self.gen_seed}")
        else:
            lines.append("gen_vel         = no")

        # Position restraints define
        if self.define:
            lines.append("")
            lines.append("; Position restraints")
            lines.append(f"define          = {self.define}")

        return lines

    def _generate_neighbor_section(self) -> List[str]:
        """Generate neighbor searching parameters."""
        lines = [
            "; Neighbor searching",
            f"cutoff-scheme   = {self.cutoff_scheme}",
            f"nstlist         = {self.nstlist}",
            f"pbc             = {self.pbc}",
            f"verlet-buffer-tolerance = {self.verlet_buffer_tolerance}",
            "",
        ]
        return lines

    def _generate_electrostatics_section(self) -> List[str]:
        """Generate electrostatics parameters."""
        lines = [
            "; Electrostatics",
            f"coulombtype     = {self.coulombtype}",
            f"rcoulomb        = {self.rcoulomb}",
            f"fourier-spacing = {self.fourier_spacing}",
            f"ewald-rtol      = {self.ewald_rtol}",
            "",
        ]
        return lines

    def _generate_vdw_section(self) -> List[str]:
        """Generate van der Waals parameters."""
        lines = [
            "; Van der Waals",
            f"vdwtype         = {self.vdwtype}",
            f"rvdw            = {self.rvdw}",
            f"vdw-modifier    = {self.vdw_modifier}",
            f"rvdw-switch     = {self.rvdw_switch}",
            f"DispCorr        = {self.dispcorr}",
            "",
        ]
        return lines


# =============================================================================
# MDP Generator
# =============================================================================


class MDPGenerator:
    """Generates GROMACS MDP files from PolyzyMD configuration.

    This class handles the conversion of PolyzyMD simulation parameters to
    GROMACS MDP format, supporting:
    - Energy minimization
    - Multi-stage equilibration with position restraints
    - Temperature ramping via GROMACS annealing
    - Production MD

    The generated MDP files use OpenFF-compatible parameters for force field
    parity with OpenMM simulations.

    Example:
        >>> generator = MDPGenerator(config)
        >>> em_mdp = generator.generate_energy_minimization()
        >>> eq_mdps = generator.generate_equilibration_stages()
        >>> prod_mdp = generator.generate_production()
    """

    def __init__(self, config: "SimulationConfig"):
        """Initialize the MDP generator.

        Args:
            config: PolyzyMD SimulationConfig object containing all simulation
                parameters including thermodynamics, simulation phases, etc.
        """
        self._config = config
        self._temperature = config.thermodynamics.temperature
        self._pressure = config.thermodynamics.pressure

    def generate_energy_minimization(
        self,
        nsteps: int = 50000,
        emtol: float = 500.0,
    ) -> MDPParameters:
        """Generate MDP parameters for energy minimization.

        Args:
            nsteps: Maximum number of minimization steps.
            emtol: Energy tolerance (kJ/mol/nm) for convergence.

        Returns:
            MDPParameters configured for steepest descent minimization.
        """
        return MDPParameters(
            title="Energy Minimization - Run FIRST before dynamics",
            stage_type="em",
            integrator="steep",
            nsteps=nsteps,
            emtol=emtol,
            emstep=0.01,
            nstlog=500,
            nstenergy=500,
        )

    def generate_equilibration_stages(self) -> List[Tuple[str, MDPParameters]]:
        """Generate MDP parameters for all equilibration stages.

        Supports both simple (single-stage) and staged equilibration modes
        from the PolyzyMD config. For staged equilibration, generates one
        MDP file per stage with appropriate naming.

        Returns:
            List of (filename, MDPParameters) tuples. Filenames follow the
            pattern "eq_01_{name}.mdp", "eq_02_{name}.mdp", etc.
        """
        phases = self._config.simulation_phases

        if phases.uses_staged_equilibration:
            return self._generate_staged_equilibration(phases.equilibration_stages)
        else:
            return self._generate_simple_equilibration(phases.equilibration)

    def _generate_simple_equilibration(
        self,
        eq_config: "SimulationPhaseConfig",
    ) -> List[Tuple[str, MDPParameters]]:
        """Generate MDP for simple single-stage equilibration.

        Args:
            eq_config: SimulationPhaseConfig for equilibration.

        Returns:
            List containing single (filename, MDPParameters) tuple.
        """
        # Determine if NVT or NPT
        is_npt = eq_config.ensemble.value == "NPT"
        stage_name = "npt" if is_npt else "nvt"

        params = self._create_equilibration_params(
            name=stage_name,
            duration_ns=eq_config.duration,
            samples=eq_config.samples,
            time_step_fs=eq_config.time_step,
            temperature=self._temperature,
            ensemble=eq_config.ensemble.value,
            thermostat=eq_config.thermostat.value if eq_config.thermostat else "LangevinMiddle",
            thermostat_timescale=eq_config.thermostat_timescale,
            barostat=eq_config.barostat.value if eq_config.barostat else None,
            is_first_stage=True,
            continuation=False,
        )

        return [(f"{stage_name}.mdp", params)]

    def _generate_staged_equilibration(
        self,
        stages: List["EquilibrationStageConfig"],
    ) -> List[Tuple[str, MDPParameters]]:
        """Generate MDPs for multi-stage equilibration protocol.

        Args:
            stages: List of EquilibrationStageConfig objects.

        Returns:
            List of (filename, MDPParameters) tuples, one per stage.
        """
        result = []

        for i, stage in enumerate(stages):
            stage_num = i + 1
            is_first = i == 0

            # Build position restraint defines
            posres_defines = self._build_posres_defines(stage)

            # Handle temperature (constant or ramping)
            if stage.is_temperature_ramping:
                params = self._create_annealing_params(
                    stage=stage,
                    stage_num=stage_num,
                    is_first_stage=is_first,
                    posres_defines=posres_defines,
                )
            else:
                # Use stage temperature or fall back to global
                temperature = stage.temperature or self._temperature

                params = self._create_equilibration_params(
                    name=stage.name,
                    duration_ns=stage.duration,
                    samples=stage.samples,
                    time_step_fs=stage.time_step or 2.0,
                    temperature=temperature,
                    ensemble=stage.ensemble.value,
                    thermostat=(stage.thermostat.value if stage.thermostat else "LangevinMiddle"),
                    thermostat_timescale=stage.thermostat_timescale or 1.0,
                    barostat=stage.barostat.value if stage.barostat else None,
                    is_first_stage=is_first,
                    continuation=not is_first,
                    posres_defines=posres_defines,
                )

            filename = f"eq_{stage_num:02d}_{stage.name}.mdp"
            result.append((filename, params))

        return result

    def _create_equilibration_params(
        self,
        name: str,
        duration_ns: float,
        samples: int,
        time_step_fs: float,
        temperature: float,
        ensemble: str,
        thermostat: str,
        thermostat_timescale: float,
        barostat: Optional[str],
        is_first_stage: bool,
        continuation: bool,
        posres_defines: str = "",
    ) -> MDPParameters:
        """Create MDPParameters for an equilibration stage.

        Args:
            name: Stage name for title.
            duration_ns: Duration in nanoseconds.
            samples: Number of trajectory frames to save.
            time_step_fs: Time step in femtoseconds.
            temperature: Target temperature in Kelvin.
            ensemble: "NVT" or "NPT".
            thermostat: Thermostat type name.
            thermostat_timescale: Thermostat coupling timescale in ps.
            barostat: Barostat type name or None.
            is_first_stage: Whether this is the first equilibration stage.
            continuation: Whether continuing from previous simulation.
            posres_defines: Position restraint defines string.

        Returns:
            Configured MDPParameters object.
        """
        dt_ps = time_step_fs / 1000.0
        nsteps = int(duration_ns * 1e6 / time_step_fs)
        output_interval = max(1, nsteps // samples) if samples > 0 else 5000

        # Map thermostat
        tcoupl = THERMOSTAT_MAP.get(thermostat, "v-rescale")

        # Map barostat
        is_npt = ensemble == "NPT"
        if is_npt and barostat:
            pcoupl, pcoupltype = BAROSTAT_MAP.get(barostat, ("c-rescale", "isotropic"))
        else:
            pcoupl, pcoupltype = "no", "isotropic"

        # Pressure in bar (config is in atm)
        ref_p = self._pressure * 1.01325

        return MDPParameters(
            title=f"{ensemble} Equilibration: {name}",
            stage_type="eq",
            integrator="md",
            dt=dt_ps,
            nsteps=nsteps,
            nstxout=output_interval,
            nstvout=output_interval,
            nstlog=output_interval,
            nstenergy=output_interval,
            nstxout_compressed=output_interval,
            continuation=continuation,
            tcoupl=tcoupl,
            tau_t=thermostat_timescale,
            ref_t=temperature,
            pcoupl=pcoupl,
            pcoupltype=pcoupltype,
            ref_p=ref_p,
            gen_vel=is_first_stage,
            gen_temp=temperature,
            define=posres_defines,
        )

    def _create_annealing_params(
        self,
        stage: "EquilibrationStageConfig",
        stage_num: int,
        is_first_stage: bool,
        posres_defines: str = "",
    ) -> MDPParameters:
        """Create MDPParameters with GROMACS annealing for temperature ramping.

        Args:
            stage: EquilibrationStageConfig with temperature ramping.
            stage_num: Stage number (1-indexed).
            is_first_stage: Whether this is the first equilibration stage.
            posres_defines: Position restraint defines string.

        Returns:
            MDPParameters configured with annealing.
        """
        time_step_fs = stage.time_step or 2.0
        dt_ps = time_step_fs / 1000.0
        nsteps = int(stage.duration * 1e6 / time_step_fs)
        samples = stage.samples
        output_interval = max(1, nsteps // samples) if samples > 0 else 5000

        # Temperature ramping parameters
        t_start = stage.temperature_start
        t_end = stage.temperature_end
        duration_ps = stage.duration * 1000  # ns to ps

        # Map thermostat
        thermostat = stage.thermostat.value if stage.thermostat else "LangevinMiddle"
        tcoupl = THERMOSTAT_MAP.get(thermostat, "v-rescale")

        # Map barostat
        is_npt = stage.ensemble.value == "NPT"
        barostat = stage.barostat.value if stage.barostat else None
        if is_npt and barostat:
            pcoupl, pcoupltype = BAROSTAT_MAP.get(barostat, ("c-rescale", "isotropic"))
        else:
            pcoupl, pcoupltype = "no", "isotropic"

        ref_p = self._pressure * 1.01325

        # GROMACS annealing: simple linear ramp
        # annealing-time: times in ps
        # annealing-temp: temperatures at those times
        annealing_time = [0.0, duration_ps]
        annealing_temp = [t_start, t_end]

        return MDPParameters(
            title=f"Temperature Ramping: {stage.name} ({t_start}K -> {t_end}K)",
            stage_type="eq",
            integrator="md",
            dt=dt_ps,
            nsteps=nsteps,
            nstxout=output_interval,
            nstvout=output_interval,
            nstlog=output_interval,
            nstenergy=output_interval,
            nstxout_compressed=output_interval,
            continuation=not is_first_stage,
            tcoupl=tcoupl,
            tau_t=stage.thermostat_timescale or 0.5,
            ref_t=t_end,  # Reference temp is final temp
            pcoupl=pcoupl,
            pcoupltype=pcoupltype,
            ref_p=ref_p,
            gen_vel=is_first_stage,
            gen_temp=t_start,  # Generate velocities at start temp
            annealing="single",
            annealing_npoints=2,
            annealing_time=annealing_time,
            annealing_temp=annealing_temp,
            define=posres_defines,
        )

    def _build_posres_defines(self, stage: "EquilibrationStageConfig") -> str:
        """Build position restraint defines string from stage config.

        Args:
            stage: EquilibrationStageConfig with position_restraints.

        Returns:
            Define string like "-DPOSRES_PROTEIN -DPOSRES_LIGAND".
        """
        if not stage.position_restraints:
            return ""

        defines = []
        for posres in stage.position_restraints:
            # Convert group name to define macro
            # protein_heavy -> POSRES_PROTEIN
            # ligand_heavy -> POSRES_LIGAND
            # polymer_heavy -> POSRES_POLYMER
            group = posres.group.upper()
            if "PROTEIN" in group:
                defines.append("-DPOSRES_PROTEIN")
            elif "LIGAND" in group:
                defines.append("-DPOSRES_LIGAND")
            elif "POLYMER" in group:
                defines.append("-DPOSRES_POLYMER")

        # Remove duplicates while preserving order
        seen = set()
        unique_defines = []
        for d in defines:
            if d not in seen:
                seen.add(d)
                unique_defines.append(d)

        return " ".join(unique_defines)

    def generate_production(self) -> MDPParameters:
        """Generate MDP parameters for production MD.

        Returns:
            MDPParameters configured for production simulation.
        """
        prod = self._config.simulation_phases.production

        dt_ps = prod.time_step / 1000.0
        nsteps = int(prod.duration * 1e6 / prod.time_step)
        output_interval = max(1, nsteps // prod.samples) if prod.samples > 0 else 5000

        # Map thermostat
        thermostat = prod.thermostat.value if prod.thermostat else "LangevinMiddle"
        tcoupl = THERMOSTAT_MAP.get(thermostat, "v-rescale")

        # Map barostat
        is_npt = prod.ensemble.value == "NPT"
        barostat = prod.barostat.value if prod.barostat else None
        if is_npt and barostat:
            pcoupl, pcoupltype = BAROSTAT_MAP.get(barostat, ("c-rescale", "isotropic"))
        else:
            pcoupl, pcoupltype = "no", "isotropic"

        ref_p = self._pressure * 1.01325 # GROMACS uses bar internally, convert from atm

        return MDPParameters(
            title=f"Production MD ({prod.duration} ns)",
            stage_type="prod",
            integrator="md",
            dt=dt_ps,
            nsteps=nsteps,
            nstxout=0,  # Don't write full precision coords
            nstvout=0,  # Don't write velocities
            nstlog=output_interval,
            nstenergy=output_interval,
            nstxout_compressed=output_interval,
            compressed_x_grps="System",
            continuation=True,
            tcoupl=tcoupl,
            tau_t=prod.thermostat_timescale,
            ref_t=self._temperature,
            pcoupl=pcoupl,
            pcoupltype=pcoupltype,
            ref_p=ref_p,
            gen_vel=False,
        )


# =============================================================================
# Position Restraint Generator
# =============================================================================


class PositionRestraintGenerator:
    """Generates GROMACS position restraint sections for molecule ITP files.

    This class adds position restraint sections directly to molecule .itp files
    using local atom indices (1 to N within each molecule), which is required
    by GROMACS. It uses the AtomGroupResolver to identify which atoms need
    restraints, then maps those to local indices within each molecule.

    GROMACS requires position restraints to be:
    1. Inside the [ moleculetype ] section of each molecule
    2. Using local atom indices (1 to N) within that molecule

    Example:
        >>> generator = PositionRestraintGenerator(topology, component_info)
        >>> generator.add_posres_to_itp_files(config, output_dir, "MySystem")
    """

    def __init__(
        self,
        topology: "OpenMMTopology",
        component_info: "SystemComponentInfo",
    ):
        """Initialize the position restraint generator.

        Args:
            topology: OpenMM Topology object from Interchange.
            component_info: SystemComponentInfo with atom counts/chain assignments.
        """
        from polyzymd.core.atom_groups import AtomGroupResolver

        self._topology = topology
        self._component_info = component_info
        self._resolver = AtomGroupResolver(topology, component_info)

    def generate(
        self,
        group_name: str,
        force_constant: float,
        output_path: Path,
    ) -> Optional[Path]:
        """Generate a position restraint file for an atom group.

        NOTE: This method generates files with GLOBAL indices, which is only
        useful for debugging. For actual GROMACS simulations, use
        add_posres_to_itp_files() instead, which adds restraints with LOCAL
        indices directly to molecule .itp files.

        Args:
            group_name: Predefined atom group name (e.g., "protein_heavy").
            force_constant: Force constant in kJ/mol/nm^2.
            output_path: Path to write the .itp file.

        Returns:
            Path to generated file, or None if group is empty.
        """
        atom_indices = self._resolver.resolve(group_name)

        if not atom_indices:
            logger.warning(f"No atoms found for group '{group_name}' - skipping posre file")
            return None

        lines = []
        lines.append(f"; Position restraints for {group_name}")
        lines.append(f"; Force constant: {force_constant} kJ/mol/nm^2")
        lines.append(f"; Generated by PolyzyMD on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        lines.append(f"; {POLYZYMD_BRANDING}")
        lines.append("; NOTE: These are GLOBAL indices for debugging only!")
        lines.append(
            "; For GROMACS, use add_posres_to_itp_files() to add LOCAL indices to .itp files"
        )
        lines.append("")
        lines.append("[ position_restraints ]")
        lines.append("; ai   funct   fcx         fcy         fcz")

        # GROMACS uses 1-indexed atoms
        for idx in atom_indices:
            atom_num = idx + 1  # Convert 0-indexed to 1-indexed
            lines.append(
                f"{atom_num:6d}  1     {force_constant:.1f}    {force_constant:.1f}    {force_constant:.1f}"
            )

        output_path.parent.mkdir(parents=True, exist_ok=True)
        output_path.write_text("\n".join(lines))

        logger.info(f"Generated position restraint file: {output_path} ({len(atom_indices)} atoms)")
        return output_path

    def add_posres_to_itp_files(
        self,
        config: "SimulationConfig",
        output_dir: Path,
        prefix: str,
    ) -> Dict[str, str]:
        """Add position restraint sections to molecule .itp files.

        This is the correct way to add position restraints for GROMACS. It:
        1. Identifies which atoms need restraints from the config
        2. Maps global indices to local molecule indices
        3. Appends #ifdef POSRES blocks to the appropriate .itp files

        Args:
            config: SimulationConfig with equilibration stages.
            output_dir: Directory containing .itp files.
            prefix: Filename prefix used for .itp files.

        Returns:
            Dictionary mapping component types to POSRES define names used.
            E.g., {"protein": "POSRES_PROTEIN", "ligand": "POSRES_LIGAND"}
        """
        phases = config.simulation_phases
        posres_defines = {}

        if not phases.uses_staged_equilibration:
            logger.info("No staged equilibration - skipping position restraints")
            return posres_defines

        # Collect all unique (group, force_constant) pairs
        restraints_needed: Dict[str, float] = {}

        for stage in phases.equilibration_stages:
            if not stage.position_restraints:
                continue
            for posres in stage.position_restraints:
                group = posres.group
                fc = posres.force_constant
                # Use the maximum force constant if same group appears multiple times
                if group not in restraints_needed or fc > restraints_needed[group]:
                    restraints_needed[group] = fc

        if not restraints_needed:
            logger.info("No position restraints configured")
            return posres_defines

        # Process each restraint group
        for group_name, force_constant in restraints_needed.items():
            # Resolve atom indices for this group
            global_indices = self._resolver.resolve(group_name)
            if not global_indices:
                logger.warning(f"No atoms found for group '{group_name}' - skipping")
                continue

            # Determine which component this group belongs to and the POSRES define
            component_type, posres_define = self._get_component_for_group(group_name)
            if component_type is None or posres_define is None:
                logger.warning(f"Cannot determine component for group '{group_name}' - skipping")
                continue

            # Find the ITP file for this component
            itp_path = self._find_itp_for_component(output_dir, prefix, component_type)
            if itp_path is None:
                logger.warning(
                    f"Cannot find ITP file for {component_type} - skipping position restraints"
                )
                continue

            # Convert global indices to local indices within this component
            # Pass itp_path for polymers so we can parse the actual atom count
            local_indices = self._convert_to_local_indices(global_indices, component_type, itp_path)
            if not local_indices:
                logger.warning(f"No local indices for group '{group_name}' - skipping")
                continue

            # Add position restraint section to the ITP file
            self._append_posres_to_itp(
                itp_path, local_indices, force_constant, posres_define, group_name
            )
            posres_defines[component_type] = posres_define

            logger.info(
                f"Added {len(local_indices)} position restraints to {itp_path.name} "
                f"(#ifdef {posres_define})"
            )

        return posres_defines

    def _get_component_for_group(self, group_name: str) -> Tuple[Optional[str], Optional[str]]:
        """Get component type and POSRES define for an atom group.

        Args:
            group_name: Atom group name (e.g., "protein_heavy", "ligand_heavy")

        Returns:
            Tuple of (component_type, posres_define) or (None, None) if unknown.
        """
        group_mapping = {
            "protein_heavy": ("protein", "POSRES_PROTEIN"),
            "protein_backbone": ("protein", "POSRES_PROTEIN"),
            "protein_calpha": ("protein", "POSRES_PROTEIN"),
            "ligand_heavy": ("ligand", "POSRES_LIGAND"),
            "polymer_heavy": ("polymer", "POSRES_POLYMER"),
        }
        return group_mapping.get(group_name, (None, None))

    def _find_itp_for_component(
        self,
        output_dir: Path,
        prefix: str,
        component_type: str,
    ) -> Optional[Path]:
        """Find the ITP file for a component type.

        OpenFF Interchange names molecules as MOL0, MOL1, MOL2, etc.
        Based on PolyzyMD building order:
        - MOL0 = protein
        - MOL1 = substrate/ligand (if present)
        - MOL2+ = polymers (if present)

        Args:
            output_dir: Directory containing ITP files.
            prefix: Filename prefix.
            component_type: "protein", "ligand", or "polymer"

        Returns:
            Path to the ITP file, or None if not found.
        """
        # Map component type to MOL index based on build order
        if component_type == "protein":
            mol_index = 0
        elif component_type == "ligand":
            # Ligand is MOL1 if protein exists, MOL0 otherwise
            mol_index = 1 if self._component_info.has_protein else 0
        elif component_type == "polymer":
            # First polymer is MOL2 if protein and ligand exist
            mol_index = 0
            if self._component_info.has_protein:
                mol_index += 1
            if self._component_info.has_substrate:
                mol_index += 1
        else:
            return None

        itp_path = output_dir / f"{prefix}_MOL{mol_index}.itp"
        if itp_path.exists():
            return itp_path

        # Try alternative naming conventions
        logger.warning(f"ITP file not found: {itp_path}")
        return None

    def _convert_to_local_indices(
        self,
        global_indices: List[int],
        component_type: str,
        itp_path: Optional[Path] = None,
    ) -> List[int]:
        """Convert global atom indices to local indices within a component.

        For polymers, this is more complex because:
        1. Multiple polymer chains may exist (e.g., 3 chains of 201 atoms each)
        2. OpenFF Interchange may create multiple molecule types (MOL2, MOL4, etc.)
        3. Each molecule type's ITP file has local indices 1 to N
        4. All copies of a molecule type share the same position restraints

        This method handles polymers by:
        1. Parsing the ITP file to get the actual atom count for that molecule type
        2. Only considering atoms from the FIRST instance of each polymer chain
        3. Converting those to local indices 1-N

        Args:
            global_indices: List of global 0-indexed atom indices.
            component_type: "protein", "ligand", or "polymer"
            itp_path: Path to the ITP file (required for polymers to get atom count)

        Returns:
            List of local 1-indexed atom indices for GROMACS.
        """
        # Calculate the starting global index for this component
        if component_type == "protein":
            start_index = 0
            n_atoms = self._component_info.n_protein_atoms
        elif component_type == "ligand":
            start_index = self._component_info.n_protein_atoms
            n_atoms = self._component_info.n_substrate_atoms
        elif component_type == "polymer":
            # For polymers, we need to handle multiple chains carefully
            # The global indices span ALL polymer atoms, but each ITP file
            # only defines ONE molecule type with N atoms.
            start_index = (
                self._component_info.n_protein_atoms + self._component_info.n_substrate_atoms
            )

            # Parse the ITP file to get the actual atom count for this molecule type
            if itp_path is not None and itp_path.exists():
                n_atoms = self._get_atom_count_from_itp(itp_path)
                logger.debug(f"Parsed {itp_path.name}: {n_atoms} atoms per molecule instance")
            else:
                # Fallback: assume first polymer chain size
                # This is a rough estimate - divide total by number of chains
                # For safety, use the first chain's worth of atoms
                n_atoms = self._component_info.n_polymer_atoms
                logger.warning(
                    f"Could not parse ITP file for polymer atom count, "
                    f"using total polymer atoms: {n_atoms}"
                )
        else:
            return []

        end_index = start_index + n_atoms

        # Filter indices that belong to this component and convert to local
        local_indices = []
        for global_idx in global_indices:
            if start_index <= global_idx < end_index:
                # Convert to 1-indexed local index
                local_idx = global_idx - start_index + 1
                local_indices.append(local_idx)

        return sorted(local_indices)

    def _get_atom_count_from_itp(self, itp_path: Path) -> int:
        """Parse an ITP file to count the number of atoms in the molecule.

        This reads the [ atoms ] section and counts entries to determine
        how many atoms are in this molecule type.

        Args:
            itp_path: Path to the ITP file.

        Returns:
            Number of atoms in the molecule type.
        """
        try:
            content = itp_path.read_text()
            in_atoms_section = False
            atom_count = 0

            for line in content.split("\n"):
                line = line.strip()

                # Skip comments and empty lines
                if not line or line.startswith(";"):
                    continue

                # Check for section headers
                if line.startswith("["):
                    section_name = line.strip("[] \t").lower()
                    in_atoms_section = section_name == "atoms"
                    continue

                # Count atoms in the [ atoms ] section
                if in_atoms_section:
                    # Atom lines start with a number (the atom index)
                    parts = line.split()
                    if parts and parts[0].isdigit():
                        atom_count += 1

            return atom_count

        except Exception as e:
            logger.warning(f"Failed to parse ITP file {itp_path}: {e}")
            return 0

    def _append_posres_to_itp(
        self,
        itp_path: Path,
        local_indices: List[int],
        force_constant: float,
        posres_define: str,
        group_name: str,
    ) -> None:
        """Append position restraint section to an ITP file.

        Args:
            itp_path: Path to the ITP file.
            local_indices: List of 1-indexed local atom indices.
            force_constant: Force constant in kJ/mol/nm^2.
            posres_define: Name of the POSRES define (e.g., "POSRES_PROTEIN").
            group_name: Name of the atom group for comments.
        """
        content = itp_path.read_text()

        # Build the position restraint section
        lines = [
            "",
            f"; Position restraints for {group_name}",
            f"; Generated by PolyzyMD - {POLYZYMD_BRANDING}",
            f"#ifdef {posres_define}",
            "[ position_restraints ]",
            "; ai   funct   fcx         fcy         fcz",
        ]

        for idx in local_indices:
            lines.append(
                f"{idx:6d}  1     {force_constant:.1f}    {force_constant:.1f}    {force_constant:.1f}"
            )

        lines.append("#endif")
        lines.append("")

        # Append to file
        new_content = content.rstrip() + "\n" + "\n".join(lines)
        itp_path.write_text(new_content)

    def generate_all_from_config(
        self,
        config: "SimulationConfig",
        output_dir: Path,
    ) -> Dict[str, Path]:
        """Generate all position restraint files needed by the config.

        DEPRECATED: This method generates standalone posre files with global
        indices, which don't work correctly with GROMACS. Use
        add_posres_to_itp_files() instead.

        Kept for backward compatibility but returns empty dict to avoid
        generating broken files.

        Args:
            config: SimulationConfig with equilibration stages.
            output_dir: Directory to write .itp files.

        Returns:
            Empty dictionary (use add_posres_to_itp_files instead).
        """
        logger.warning(
            "generate_all_from_config() is deprecated for GROMACS. "
            "Position restraints are now added directly to molecule .itp files."
        )
        return {}

        return generated


# =============================================================================
# Topology Modifier
# =============================================================================


class TopologyModifier:
    """Modifies GROMACS topology files for position restraints.

    This class post-processes .top files generated by OpenFF Interchange
    to add #ifdef POSRES blocks that include position restraint files.
    """

    # Mapping from atom group to POSRES define and component pattern
    POSRES_MAPPING = {
        "protein_heavy": ("POSRES_PROTEIN", r"^\[ moleculetype \].*?^(\S+)"),
        "protein_backbone": ("POSRES_PROTEIN", r"^\[ moleculetype \].*?^(\S+)"),
        "protein_calpha": ("POSRES_PROTEIN", r"^\[ moleculetype \].*?^(\S+)"),
        "ligand_heavy": ("POSRES_LIGAND", None),  # Ligand uses residue name
        "polymer_heavy": ("POSRES_POLYMER", None),  # Polymer detection TBD
    }

    def __init__(self, top_path: Path):
        """Initialize the topology modifier.

        Args:
            top_path: Path to the .top file to modify.
        """
        self._top_path = top_path
        self._content = top_path.read_text()

    def add_posres_includes(
        self,
        posres_files: Dict[str, Path],
    ) -> None:
        """Add #ifdef POSRES blocks to include position restraint files.

        Modifies the topology file in place to add include directives for
        position restraint files at appropriate locations.

        Args:
            posres_files: Dictionary mapping group names to posre file paths.
        """
        if not posres_files:
            return

        modified_content = self._content

        # Add protein position restraints after protein moleculetype
        if (
            "protein_heavy" in posres_files
            or "protein_backbone" in posres_files
            or "protein_calpha" in posres_files
        ):
            # Find the best posre file (prefer heavy atoms)
            for group in ["protein_heavy", "protein_backbone", "protein_calpha"]:
                if group in posres_files:
                    posre_file = posres_files[group]
                    modified_content = self._insert_posres_after_protein(
                        modified_content, posre_file, "POSRES_PROTEIN"
                    )
                    break

        # Add ligand position restraints
        if "ligand_heavy" in posres_files:
            posre_file = posres_files["ligand_heavy"]
            modified_content = self._insert_posres_after_ligand(
                modified_content, posre_file, "POSRES_LIGAND"
            )

        # Add polymer position restraints
        if "polymer_heavy" in posres_files:
            posre_file = posres_files["polymer_heavy"]
            modified_content = self._insert_posres_after_polymer(
                modified_content, posre_file, "POSRES_POLYMER"
            )

        # Write modified content
        self._top_path.write_text(modified_content)
        logger.info(f"Modified topology file with position restraint includes: {self._top_path}")

    def _insert_posres_after_protein(
        self,
        content: str,
        posre_file: Path,
        define_name: str,
    ) -> str:
        """Insert POSRES include after protein molecule definition.

        Finds the first moleculetype (assumed to be protein) and inserts
        the posres include after its atoms section.
        """
        # Pattern to find end of first moleculetype's atoms section
        # We insert after [ atoms ] section of first molecule
        pattern = r"(\[ atoms \].*?(?=\n\[ bonds \]|\n\[ moleculetype \]|\Z))"

        def insert_posres(match):
            atoms_section = match.group(1)
            posres_block = f'\n\n#ifdef {define_name}\n#include "{posre_file.name}"\n#endif\n'
            return atoms_section + posres_block

        # Only replace the first occurrence (protein)
        return re.sub(pattern, insert_posres, content, count=1, flags=re.DOTALL)

    def _insert_posres_after_ligand(
        self,
        content: str,
        posre_file: Path,
        define_name: str,
    ) -> str:
        """Insert POSRES include after ligand molecule definition.

        This is tricky because we need to identify the ligand moleculetype.
        We look for small molecules that aren't water/ions.
        """
        # For now, insert at end of topology before [ system ]
        posres_block = f'\n#ifdef {define_name}\n#include "{posre_file.name}"\n#endif\n'

        # Insert before [ system ] if present
        if "[ system ]" in content:
            content = content.replace("[ system ]", posres_block + "\n[ system ]")
        else:
            content += posres_block

        return content

    def _insert_posres_after_polymer(
        self,
        content: str,
        posre_file: Path,
        define_name: str,
    ) -> str:
        """Insert POSRES include for polymer molecules."""
        # Similar to ligand - insert before [ system ]
        posres_block = f'\n#ifdef {define_name}\n#include "{posre_file.name}"\n#endif\n'

        if "[ system ]" in content:
            content = content.replace("[ system ]", posres_block + "\n[ system ]")
        else:
            content += posres_block

        return content


# =============================================================================
# Run Script Generator
# =============================================================================


class RunScriptGenerator:
    """Generates GROMACS run scripts for the full simulation workflow.

    Creates shell scripts that execute the complete GROMACS workflow:
    1. Energy minimization
    2. Equilibration stages
    3. Production MD
    4. Trajectory post-processing (PBC unwrapping)
    """

    def __init__(
        self,
        prefix: str,
        equilibration_mdps: List[str],
        gmx_command: str = "gmx",
    ):
        """Initialize the run script generator.

        Args:
            prefix: System prefix for file naming.
            equilibration_mdps: List of equilibration MDP filenames.
            gmx_command: GROMACS command (default "gmx", can be path).
        """
        self._prefix = prefix
        self._eq_mdps = equilibration_mdps
        self._gmx = gmx_command

    def generate(self, output_path: Path) -> Path:
        """Generate the GROMACS run script.

        Args:
            output_path: Path to write the script.

        Returns:
            Path to the generated script.
        """
        lines = self._generate_header()
        lines.extend(self._generate_energy_minimization())
        lines.extend(self._generate_equilibration())
        lines.extend(self._generate_production())
        lines.extend(self._generate_postprocessing())
        lines.extend(self._generate_footer())

        content = "\n".join(lines)
        output_path.write_text(content)
        output_path.chmod(0o755)  # Make executable

        logger.info(f"Generated GROMACS run script: {output_path}")
        return output_path

    def _generate_header(self) -> List[str]:
        """Generate script header with configuration."""
        return [
            "#!/bin/bash",
            f"# GROMACS Workflow Script",
            f"# {POLYZYMD_BRANDING}",
            f"# Generated on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
            "#",
            "# Usage: ./run_gromacs.sh",
            "#",
            "# This script runs the complete MD workflow:",
            "#   1. Energy minimization",
            "#   2. Equilibration (multiple stages if configured)",
            "#   3. Production MD",
            "#   4. Trajectory post-processing",
            "",
            "set -e  # Exit on error",
            "",
            "# Configuration",
            f'GMX="{self._gmx}"',
            f'PREFIX="{self._prefix}"',
            "",
            'echo "========================================"',
            f'echo "GROMACS Workflow for ${{PREFIX}}"',
            'echo "========================================"',
            'echo "Using GROMACS: $GMX"',
            'echo ""',
            "",
        ]

    def _generate_energy_minimization(self) -> List[str]:
        """Generate energy minimization commands."""
        return [
            "# ========================================",
            "# Step 1: Energy Minimization",
            "# ========================================",
            'echo "=== Step 1: Energy Minimization ==="',
            "",
            "$GMX grompp -f em.mdp -c ${PREFIX}.gro -p ${PREFIX}.top -o em.tpr -maxwarn 1",
            "$GMX mdrun -deffnm em -v",
            "",
            "# Check if minimization succeeded",
            "if [ ! -f em.gro ]; then",
            '    echo "ERROR: Energy minimization failed!"',
            "    exit 1",
            "fi",
            'echo "Minimization complete: em.gro"',
            'echo ""',
            "",
        ]

    def _generate_equilibration(self) -> List[str]:
        """Generate equilibration stage commands."""
        lines = [
            "# ========================================",
            "# Step 2: Equilibration",
            "# ========================================",
        ]

        prev_output = "em"

        for i, mdp_file in enumerate(self._eq_mdps):
            stage_num = i + 1
            mdp_name = Path(mdp_file).stem  # Remove .mdp extension
            output_name = f"eq_{stage_num:02d}"

            lines.extend(
                [
                    f'echo "=== Step 2.{stage_num}: Equilibration - {mdp_name} ==="',
                    "",
                ]
            )

            # Build grompp command
            # Always use -r em.gro for reference coordinates (needed for position restraints)
            grompp_cmd = f"$GMX grompp -f {mdp_file} -c {prev_output}.gro -r em.gro"
            if prev_output != "em":
                grompp_cmd += f" -t {prev_output}.cpt"
            grompp_cmd += f" -p ${{PREFIX}}.top -o {output_name}.tpr -maxwarn 1"

            lines.extend(
                [
                    grompp_cmd,
                    f"$GMX mdrun -deffnm {output_name} -v",
                    "",
                    f"if [ ! -f {output_name}.gro ]; then",
                    f'    echo "ERROR: Equilibration stage {stage_num} failed!"',
                    "    exit 1",
                    "fi",
                    f'echo "Equilibration stage {stage_num} complete: {output_name}.gro"',
                    'echo ""',
                    "",
                ]
            )

            prev_output = output_name

        # Store last equilibration output for production
        lines.append(f'LAST_EQ="{prev_output}"')
        lines.append("")

        return lines

    def _generate_production(self) -> List[str]:
        """Generate production MD commands."""
        return [
            "# ========================================",
            "# Step 3: Production MD",
            "# ========================================",
            'echo "=== Step 3: Production MD ==="',
            "",
            "$GMX grompp -f prod.mdp -c ${LAST_EQ}.gro -t ${LAST_EQ}.cpt -p ${PREFIX}.top -o prod.tpr -maxwarn 1",
            "$GMX mdrun -deffnm prod -v",
            "",
            'echo "Production complete: prod.xtc"',
            'echo ""',
            "",
        ]

    def _generate_postprocessing(self) -> List[str]:
        """Generate trajectory post-processing commands."""
        return [
            "# ========================================",
            "# Step 4: Trajectory Post-processing",
            "# ========================================",
            'echo "=== Step 4: Trajectory Post-processing ==="',
            'echo "Removing PBC jumps and centering..."',
            "",
            "# Remove periodic boundary jumps",
            'echo "System" | $GMX trjconv -s prod.tpr -f prod.xtc -o prod_nojump.xtc -pbc nojump',
            "",
            "# Center and make molecules whole",
            'echo -e "Protein\\nSystem" | $GMX trjconv -s prod.tpr -f prod_nojump.xtc -o prod_centered.xtc -center -pbc mol -ur compact',
            "",
            'echo "Post-processing complete."',
            'echo "  - prod_nojump.xtc: Trajectory without PBC jumps"',
            '  echo "  - prod_centered.xtc: Centered trajectory for visualization"',
            'echo ""',
            "",
        ]

    def _generate_footer(self) -> List[str]:
        """Generate script footer with summary."""
        return [
            "# ========================================",
            "# Workflow Complete",
            "# ========================================",
            'echo "========================================"',
            'echo "Workflow Complete!"',
            'echo "========================================"',
            'echo ""',
            'echo "Output files:"',
            'echo "  em.gro             - Minimized structure"',
            'echo "  eq_*.gro           - Equilibrated structures"',
            'echo "  prod.xtc           - Production trajectory"',
            'echo "  prod.edr           - Energy file"',
            'echo "  prod.log           - Log file"',
            'echo "  prod_centered.xtc  - Centered trajectory for visualization"',
            'echo ""',
            f'echo "{POLYZYMD_BRANDING}"',
        ]


# =============================================================================
# Main Exporter Class
# =============================================================================


class GromacsExporter:
    """Coordinates full GROMACS export from PolyzyMD systems.

    This is the main entry point for GROMACS export. It coordinates:
    - Coordinate/topology export via Interchange
    - MDP file generation from config
    - Position restraint file generation
    - Topology modification for posres includes
    - Run script generation

    Example:
        >>> exporter = GromacsExporter(interchange, config, component_info)
        >>> exporter.export(output_dir, prefix="my_system")
    """

    def __init__(
        self,
        interchange: "Interchange",
        config: "SimulationConfig",
        component_info: Optional["SystemComponentInfo"] = None,
    ):
        """Initialize the GROMACS exporter.

        Args:
            interchange: OpenFF Interchange object with parameterized system.
            config: PolyzyMD SimulationConfig with simulation parameters.
            component_info: Optional SystemComponentInfo for position restraints.
                If not provided, position restraints will be skipped.
        """
        self._interchange = interchange
        self._config = config
        self._component_info = component_info

    def export(
        self,
        output_dir: Union[str, Path],
        prefix: Optional[str] = None,
        gmx_command: str = "gmx",
    ) -> Dict[str, Path]:
        """Export the complete GROMACS simulation setup.

        Args:
            output_dir: Directory to write all files.
            prefix: Filename prefix. If None, generates from config.
            gmx_command: GROMACS command for run script.

        Returns:
            Dictionary mapping file types to paths:
            - "gro": Coordinate file
            - "top": Topology file
            - "em_mdp": Energy minimization MDP
            - "eq_mdps": List of equilibration MDP paths
            - "prod_mdp": Production MDP
            - "posres": Dictionary of position restraint files
            - "run_script": Run script path
        """
        output_dir = Path(output_dir)
        output_dir.mkdir(parents=True, exist_ok=True)

        if prefix is None:
            prefix = self._generate_prefix()

        result: Dict[str, any] = {}

        # Step 1: Export coordinates and topology via Interchange
        logger.info("Exporting coordinates and topology...")
        gro_path, top_path = self._export_interchange(output_dir, prefix)
        result["gro"] = gro_path
        result["top"] = top_path

        # Step 2: Generate MDP files
        logger.info("Generating MDP files...")
        mdp_generator = MDPGenerator(self._config)

        # Energy minimization
        em_params = mdp_generator.generate_energy_minimization()
        em_path = output_dir / "em.mdp"
        em_path.write_text(em_params.to_mdp_string())
        result["em_mdp"] = em_path

        # Equilibration stages
        eq_mdps = mdp_generator.generate_equilibration_stages()
        eq_paths = []
        for filename, params in eq_mdps:
            mdp_path = output_dir / filename
            mdp_path.write_text(params.to_mdp_string())
            eq_paths.append(mdp_path)
        result["eq_mdps"] = eq_paths

        # Production
        prod_params = mdp_generator.generate_production()
        prod_path = output_dir / "prod.mdp"
        prod_path.write_text(prod_params.to_mdp_string())
        result["prod_mdp"] = prod_path

        # Step 3: Add position restraints to molecule ITP files (if component_info available)
        result["posres"] = {}
        result["posres_defines"] = {}
        if self._component_info is not None:
            logger.info("Adding position restraints to molecule ITP files...")
            topology = self._interchange.to_openmm_topology()
            posres_generator = PositionRestraintGenerator(topology, self._component_info)
            posres_defines = posres_generator.add_posres_to_itp_files(
                self._config, output_dir, prefix
            )
            result["posres_defines"] = posres_defines

            # Track which components have posres for user info
            if posres_defines:
                logger.info(f"Position restraints added for: {', '.join(posres_defines.keys())}")
                logger.info(f"POSRES defines: {', '.join(posres_defines.values())}")

        # Step 4: Generate run script
        logger.info("Generating run script...")
        eq_mdp_names = [p.name for p in eq_paths]
        script_generator = RunScriptGenerator(prefix, eq_mdp_names, gmx_command)
        script_path = output_dir / f"run_{prefix}_gromacs.sh"
        script_generator.generate(script_path)
        result["run_script"] = script_path

        # Log summary
        self._log_summary(result, output_dir)

        return result

    def _export_interchange(
        self,
        output_dir: Path,
        prefix: str,
    ) -> Tuple[Path, Path]:
        """Export Interchange to GROMACS format.

        Args:
            output_dir: Output directory.
            prefix: Filename prefix.

        Returns:
            Tuple of (gro_path, top_path).
        """
        # Fix 0-indexed residues for GROMACS
        self._fix_zero_indexed_residues()

        # Export using Interchange
        output_prefix = str(output_dir / prefix)
        self._interchange.to_gromacs(
            prefix=output_prefix,
            monolithic=False,
            _merge_atom_types=True,
        )

        gro_path = output_dir / f"{prefix}.gro"
        top_path = output_dir / f"{prefix}.top"

        # Remove the stub MDP generated by Interchange
        stub_mdp = output_dir / f"{prefix}.mdp"
        if stub_mdp.exists():
            stub_mdp.unlink()

        # Fix include paths in topology file
        # Interchange writes absolute-looking paths relative to CWD, but GROMACS
        # needs paths relative to the .top file location
        self._fix_topology_include_paths(top_path, output_dir, prefix)

        return gro_path, top_path

    def _fix_topology_include_paths(
        self,
        top_path: Path,
        output_dir: Path,
        prefix: str,
    ) -> None:
        """Fix #include paths in topology file to be relative to .top location.

        OpenFF Interchange writes include paths relative to the current working
        directory at export time (e.g., "output_files/replicate_1/gromacs/file.itp").
        GROMACS expects paths relative to the .top file location, so we need to
        convert them to just the filename (e.g., "file.itp").

        Args:
            top_path: Path to the topology file.
            output_dir: Directory containing the topology file.
            prefix: Filename prefix used for the export.
        """
        import re

        content = top_path.read_text()

        # Pattern to match #include directives with paths containing our prefix
        # This matches: #include "any/path/prefix_something.itp"
        # And converts to: #include "prefix_something.itp"
        include_pattern = re.compile(r'#include\s+"([^"]*/' + re.escape(prefix) + r'_[^"]+\.itp)"')

        def fix_path(match: re.Match) -> str:
            full_path = match.group(1)
            # Extract just the filename
            filename = Path(full_path).name
            return f'#include "{filename}"'

        new_content = include_pattern.sub(fix_path, content)

        # Only write if we made changes
        if new_content != content:
            top_path.write_text(new_content)
            logger.info(f"Fixed include paths in topology file: {top_path.name}")

    def _fix_zero_indexed_residues(self) -> None:
        """Fix 0-indexed residues for GROMACS compatibility."""
        found_zero_indexed = False

        for molecule in self._interchange.topology.molecules:
            for atom in molecule.atoms:
                residue_num = atom.metadata.get("residue_number")
                if residue_num is not None:
                    if isinstance(residue_num, str):
                        try:
                            if int(residue_num) == 0:
                                found_zero_indexed = True
                                break
                        except ValueError:
                            pass
                    elif residue_num == 0:
                        found_zero_indexed = True
                        break
            if found_zero_indexed:
                break

        if not found_zero_indexed:
            return

        logger.info("Fixing 0-indexed residues for GROMACS compatibility")
        for molecule in self._interchange.topology.molecules:
            for atom in molecule.atoms:
                residue_num = atom.metadata.get("residue_number")
                if residue_num is not None:
                    if isinstance(residue_num, str):
                        try:
                            atom.metadata["residue_number"] = str(int(residue_num) + 1)
                        except ValueError:
                            pass
                    else:
                        atom.metadata["residue_number"] = residue_num + 1

    def _generate_prefix(self) -> str:
        """Generate filename prefix from config."""
        parts = []

        if self._config.enzyme:
            parts.append(self._config.enzyme.name)

        if self._config.polymers and self._config.polymers.enabled:
            parts.append(self._config.polymers.type_prefix)

        return "_".join(parts) if parts else "system"

    def _log_summary(self, result: Dict[str, any], output_dir: Path) -> None:
        """Log summary of generated files."""
        logger.info("")
        logger.info("=" * 60)
        logger.info("GROMACS Export Complete")
        logger.info("=" * 60)
        logger.info(f"Output directory: {output_dir}")
        logger.info("")
        logger.info("Generated files:")
        logger.info(f"  Coordinates:      {result['gro'].name}")
        logger.info(f"  Topology:         {result['top'].name}")
        logger.info(f"  Energy min MDP:   {result['em_mdp'].name}")
        for eq_path in result["eq_mdps"]:
            logger.info(f"  Equilibration:    {eq_path.name}")
        logger.info(f"  Production MDP:   {result['prod_mdp'].name}")
        if result.get("posres_defines"):
            logger.info("  Position restraints added to molecule ITP files:")
            for component, define in result["posres_defines"].items():
                logger.info(f"    - {component}: #ifdef {define}")
        logger.info(f"  Run script:       {result['run_script'].name}")
        logger.info("")
        logger.info(f"To run: cd {output_dir} && ./{result['run_script'].name}")
        logger.info("")
        logger.info(POLYZYMD_BRANDING)


# =============================================================================
# GROMACS Runner (Local Execution)
# =============================================================================


class GromacsError(Exception):
    """Exception raised when a GROMACS command fails."""

    def __init__(self, command: str, returncode: int, message: str = ""):
        self.command = command
        self.returncode = returncode
        self.message = message
        super().__init__(f"GROMACS command failed: {command} (exit code {returncode})")


class GromacsRunner:
    """Execute GROMACS workflow from exported files with streaming output.

    This class runs the complete GROMACS MD workflow locally, streaming
    all output to stdout in real-time for familiar GROMACS user experience.

    The workflow consists of:
        1. Energy minimization (grompp + mdrun)
        2. Equilibration stages (loop of grompp + mdrun)
        3. Production MD (grompp + mdrun)
        4. Trajectory post-processing (trjconv)

    On any failure, execution stops immediately and all intermediate files
    are preserved for debugging.

    Example:
        >>> runner = GromacsRunner(
        ...     working_dir=Path("./gromacs"),
        ...     prefix="lysozyme_PEG",
        ...     equilibration_mdps=["eq_01_nvt.mdp", "eq_02_npt.mdp"],
        ... )
        >>> runner.run_full_workflow()
    """

    def __init__(
        self,
        working_dir: Path,
        prefix: str,
        equilibration_mdps: List[str],
        gmx_command: str = "gmx",
    ):
        """Initialize the GROMACS runner.

        Args:
            working_dir: Directory containing GROMACS input files.
            prefix: System prefix for filenames (e.g., "lysozyme_PEG").
            equilibration_mdps: List of equilibration MDP filenames in order.
            gmx_command: Path to GROMACS executable (default: "gmx").
        """
        self._working_dir = Path(working_dir)
        self._prefix = prefix
        self._eq_mdps = equilibration_mdps
        self._gmx = gmx_command

        # Track state for workflow
        self._last_eq_output: Optional[str] = None

    def run_full_workflow(self) -> None:
        """Run the complete GROMACS workflow.

        Executes energy minimization, equilibration, production, and
        post-processing in sequence. Stops immediately on any failure.

        Raises:
            GromacsError: If any GROMACS command fails.
            FileNotFoundError: If required input files are missing.
        """
        self._print_banner("GROMACS Workflow", f"System: {self._prefix}")

        # Verify input files exist
        self._verify_inputs()

        # Run workflow steps
        self._run_energy_minimization()
        self._run_equilibration()
        self._run_production()
        self._run_postprocessing()

        self._print_summary()

    def _verify_inputs(self) -> None:
        """Verify that required input files exist."""
        required_files = [
            f"{self._prefix}.gro",
            f"{self._prefix}.top",
            "em.mdp",
            "prod.mdp",
        ]
        required_files.extend(self._eq_mdps)

        missing = []
        for filename in required_files:
            filepath = self._working_dir / filename
            if not filepath.exists():
                missing.append(filename)

        if missing:
            raise FileNotFoundError(
                f"Missing required files in {self._working_dir}: {', '.join(missing)}"
            )

    def _run_command(
        self,
        cmd: List[str],
        description: str,
        stdin_input: Optional[str] = None,
    ) -> None:
        """Run a command with streaming stdout/stderr.

        Args:
            cmd: Command and arguments as list.
            description: Human-readable description for logging.
            stdin_input: Optional string to pipe to stdin.

        Raises:
            GromacsError: If command returns non-zero exit code.
        """
        import subprocess
        import sys

        print(f"\n>>> {description}")
        print(f">>> Command: {' '.join(cmd)}")
        print("-" * 60)

        try:
            process = subprocess.Popen(
                cmd,
                cwd=self._working_dir,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                stdin=subprocess.PIPE if stdin_input else None,
                text=True,
                bufsize=1,  # Line buffered
            )

            # If we have stdin input, write it and close
            if stdin_input:
                process.stdin.write(stdin_input)
                process.stdin.close()

            # Stream output line by line
            for line in process.stdout:
                sys.stdout.write(line)
                sys.stdout.flush()

            process.wait()

            if process.returncode != 0:
                raise GromacsError(
                    command=" ".join(cmd),
                    returncode=process.returncode,
                    message=f"Step failed: {description}",
                )

            print("-" * 60)
            print(f">>> {description} completed successfully")

        except FileNotFoundError:
            raise GromacsError(
                command=cmd[0],
                returncode=-1,
                message=f"GROMACS executable not found: {self._gmx}. "
                "Ensure GROMACS is installed and in your PATH, or use --gmx-path.",
            )

    def _run_energy_minimization(self) -> None:
        """Run energy minimization step."""
        self._print_banner("Step 1: Energy Minimization")

        # grompp
        self._run_command(
            [
                self._gmx,
                "grompp",
                "-f",
                "em.mdp",
                "-c",
                f"{self._prefix}.gro",
                "-p",
                f"{self._prefix}.top",
                "-o",
                "em.tpr",
                "-maxwarn",
                "1",
            ],
            "Preparing energy minimization (grompp)",
        )

        # mdrun
        self._run_command(
            [self._gmx, "mdrun", "-deffnm", "em", "-v"],
            "Running energy minimization (mdrun)",
        )

        # Verify output
        if not (self._working_dir / "em.gro").exists():
            raise GromacsError(
                command="mdrun -deffnm em",
                returncode=1,
                message="Energy minimization failed: em.gro not produced",
            )

    def _run_equilibration(self) -> None:
        """Run all equilibration stages."""
        self._print_banner("Step 2: Equilibration", f"{len(self._eq_mdps)} stage(s)")

        prev_output = "em"

        for i, mdp_file in enumerate(self._eq_mdps):
            stage_num = i + 1
            output_name = f"eq_{stage_num:02d}"

            print(f"\n=== Equilibration Stage {stage_num}/{len(self._eq_mdps)}: {mdp_file} ===")

            # Build grompp command
            # Always use -r em.gro for reference coordinates (needed for position restraints)
            grompp_cmd = [
                self._gmx,
                "grompp",
                "-f",
                mdp_file,
                "-c",
                f"{prev_output}.gro",
                "-r",
                "em.gro",
                "-p",
                f"{self._prefix}.top",
                "-o",
                f"{output_name}.tpr",
                "-maxwarn",
                "1",
            ]

            # Add checkpoint from previous stage (except after EM)
            if prev_output != "em":
                grompp_cmd.extend(["-t", f"{prev_output}.cpt"])

            self._run_command(
                grompp_cmd,
                f"Preparing equilibration stage {stage_num} (grompp)",
            )

            # mdrun
            self._run_command(
                [self._gmx, "mdrun", "-deffnm", output_name, "-v"],
                f"Running equilibration stage {stage_num} (mdrun)",
            )

            # Verify output
            if not (self._working_dir / f"{output_name}.gro").exists():
                raise GromacsError(
                    command=f"mdrun -deffnm {output_name}",
                    returncode=1,
                    message=f"Equilibration stage {stage_num} failed: {output_name}.gro not produced",
                )

            prev_output = output_name

        self._last_eq_output = prev_output

    def _run_production(self) -> None:
        """Run production MD."""
        self._print_banner("Step 3: Production MD")

        if self._last_eq_output is None:
            raise RuntimeError("Equilibration must complete before production")

        # grompp
        self._run_command(
            [
                self._gmx,
                "grompp",
                "-f",
                "prod.mdp",
                "-c",
                f"{self._last_eq_output}.gro",
                "-t",
                f"{self._last_eq_output}.cpt",
                "-p",
                f"{self._prefix}.top",
                "-o",
                "prod.tpr",
                "-maxwarn",
                "1",
            ],
            "Preparing production MD (grompp)",
        )

        # mdrun
        self._run_command(
            [self._gmx, "mdrun", "-deffnm", "prod", "-v"],
            "Running production MD (mdrun)",
        )

        # Verify output
        if not (self._working_dir / "prod.xtc").exists():
            raise GromacsError(
                command="mdrun -deffnm prod",
                returncode=1,
                message="Production MD failed: prod.xtc not produced",
            )

    def _run_postprocessing(self) -> None:
        """Run trajectory post-processing with trjconv."""
        self._print_banner("Step 4: Trajectory Post-processing")

        print("Removing periodic boundary jumps and centering trajectory...")

        # Step 1: Remove PBC jumps
        # echo "System" | gmx trjconv -s prod.tpr -f prod.xtc -o prod_nojump.xtc -pbc nojump
        self._run_command(
            [
                self._gmx,
                "trjconv",
                "-s",
                "prod.tpr",
                "-f",
                "prod.xtc",
                "-o",
                "prod_nojump.xtc",
                "-pbc",
                "nojump",
            ],
            "Removing PBC jumps (trjconv)",
            stdin_input="System\n",
        )

        # Step 2: Center on protein and make molecules whole
        # echo -e "Protein\nSystem" | gmx trjconv -s prod.tpr -f prod_nojump.xtc -o prod_centered.xtc -center -pbc mol -ur compact
        self._run_command(
            [
                self._gmx,
                "trjconv",
                "-s",
                "prod.tpr",
                "-f",
                "prod_nojump.xtc",
                "-o",
                "prod_centered.xtc",
                "-center",
                "-pbc",
                "mol",
                "-ur",
                "compact",
            ],
            "Centering trajectory (trjconv)",
            stdin_input="Protein\nSystem\n",
        )

    def _print_banner(self, title: str, subtitle: str = "") -> None:
        """Print a section banner."""
        print("\n" + "=" * 60)
        print(title)
        if subtitle:
            print(subtitle)
        print("=" * 60)

    def _print_summary(self) -> None:
        """Print workflow completion summary."""
        self._print_banner("Workflow Complete!", POLYZYMD_BRANDING)
        print("\nOutput files:")
        print(f"  em.gro              - Minimized structure")
        for i in range(len(self._eq_mdps)):
            print(f"  eq_{i + 1:02d}.gro           - Equilibrated structure (stage {i + 1})")
        print(f"  prod.xtc            - Production trajectory")
        print(f"  prod.edr            - Energy file")
        print(f"  prod.log            - Log file")
        print(f"  prod_nojump.xtc     - Trajectory without PBC jumps")
        print(f"  prod_centered.xtc   - Centered trajectory for visualization")
        print(f"\nAll files in: {self._working_dir}")
